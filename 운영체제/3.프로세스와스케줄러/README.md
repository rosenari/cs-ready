## 프로세스란 ?

- 실행중인 프로그램(메모리에 적재되어 운영체제의 제어를 받는 프로그램)
- 프로세스 = task = job
- 응용 프로그램과 프로세스는 다르다.
    - 응용 프로그램은 여러개의 프로세스로 이루어 질 수 있다.
- 하나의 응용프로그램은 여러 프로세스(프로그램)가 상호작용 하면서 실행 될 수 있다.

## 스케쥴러

- 프로세스 실행을 관리한다.
- 스케쥴링 알고리즘 : 어떠한 순서로 프로세스를 실행할지 결정
    - 스케쥴링 알고리즘의 목표 : 프로세스 응답시간 최소화(시분할 시스템)를 한거나, CPU 활용도를 높힌다거나(멀티프로그래밍)

## 스케쥴러의 종류

1. FIFO 스케쥴러

- 프로세스를 요청 순서대로 프로세서에 할당한다.(배치 처리 시스템과 동일하다.)
- FCFS(Fisrt Come First Served)라고도 불린다.

![image](https://user-images.githubusercontent.com/49670068/118975463-00df9480-b9af-11eb-8c5d-8b038ab85cfe.png)


2. SJF(Shortest Job First) 스케쥴러

- 실행시간이 가장 짧은 프로세스를 먼저 실행한다.

![image](https://user-images.githubusercontent.com/49670068/118975570-19e84580-b9af-11eb-99f2-39fd093bc991.png)


> ※ RTOS(RealTime OS)와 GPOS(General Purpose OS)
> RTOS: 프로그램의 시작과 종료시간을 완전히 보장하는 OS이다. 언제 프로그램을 정확히 끝내야하는 민감한 작업이 필요한 곳에 사용된다.(원자력 발전소 등등)
> GPOS: 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS(윈도우,리눅스등 이있다.)

3. 우선순위 기반 스케쥴러

- 프로세스 우선순위가 높은 것을 우선적으로 프로세스에 할당하는 스케쥴러이다.
- 정적 우선순위 스케쥴러(프로세스마다 우선순위에 고정적), 동적 우선순위 스케쥴러(스케쥴러 상황에따라 우선순위가 동적으로 변경)가 있다.

![image](https://user-images.githubusercontent.com/49670068/118975934-6c296680-b9af-11eb-9184-0ce7ba10dcf0.png)


4. Round Robin 스케쥴러

- 시분할 시스템에 기반되는 스케쥴러이다.
- 실행되는 프로세스가 일정시간 사용하면 스케쥴러가 선점(점유)하여 중지시키고 다른 프로세스가 실행되도록 한다.

![image](https://user-images.githubusercontent.com/49670068/118976312-d9d59280-b9af-11eb-9da0-cefa587d3f85.png)


## 멀티프로그래밍과 Wait

- 멀티프로그래밍 CPU활용도를 극대화 하는 스케쥴링 알고리즘
- Wait : 저장매체로 부터 파일 읽기를 기다리는 시간으로 가정

![image](https://user-images.githubusercontent.com/49670068/118976712-45b7fb00-b9b0-11eb-872f-894863dec579.png)

> 위 그림에서 한 네모당 1초라고 가정 한다면 각 프로그램들의 실제 프로세서 사용시간은 2초이다. 그리고 각 프로세스가 Wait 상태일때, Wait상태가 아닌 프로세스를 프로세서에 할당하여 cpu 활용도를 높힐 수 있다.

## 프로세스 상태

![image](https://user-images.githubusercontent.com/49670068/118976989-a21b1a80-b9b0-11eb-8499-9851a4ef013a.png)

- Run 상태 : 현재 CPU에서 실행중인 상태
- Ready 상태 : CPU를 통해 바로 실행가능한 상태
- Wait(Block) 상태 : 특정 이벤트 발생을 기다리는 상태(예를 들어 파일을 저장매체에서 다 읽게되면 저장매체는 OS로 이벤트를 날리는 데, 이 이벤트를 기다리는 상태이다. 이벤트를 받으면 스케쥴러에 의해 Ready상태가 된다.)

## 프로세스 상태간의 관계

![image](https://user-images.githubusercontent.com/49670068/118977630-561ca580-b9b1-11eb-9d42-cebfb3cbef8a.png)

- RUN => WAIT (IO or Event Wait) : 예를 들어 프로그램에서 open함수로 인해 파일읽기(시스템 콜 : 이것도 인터럽트임)가 수행되는 경우 인터럽트(파일읽기가 완료됐다는 이벤트)가 발생할때까지 대기하는 Wait상태가 된다.
- READY => RUN : 스케쥴러에 의해 프로세스가 프로세서에 할당되어 실행된다.
- RUN => READY : 스케쥴러에 의해 실행중인 프로세스가 선점되어 READY상태로 전환된다
- WAIT => READY : 인터럽트(파일읽기가 완료됐다는 이벤트)가 발생하면 스케쥴러에 의해 READY상태로 전환된다.

## 선점형 스케쥴러와 비선점형 스케쥴러의 차이

- 선점형 스케쥴러 : 스케쥴러가 실행중인 프로세스를 선점하여 중지후 다른 프로세스를 실행시킬 수 있음.
- 비선점형 스케쥴러 : 스케쥴러가 실행중인 프로세스를 선점할 수 없으며, 실행 중 Wait상태가 되지않는 프로세스의 경우 끝날때까지 다른 프로세스를 실행시킬수 없다. (프로세스가 종료되거나 Wait가 되는 경우에만 다른 프로세스를 실행시킬수 있다.)

> `FIFO, SJF, 우선순위 스케쥴러`의 경우 `어떤 프로세스를 먼저 실행`시킬 지에 대한 스케쥴러이며, `Round Robin`은 `시분할 시스템을 위한 선점 스케쥴러`이다.

## 여러 스케쥴링 알고리즘이 조합되어 동작할 수 있습니다.

- 예를 들어 우선순위 스케쥴링과 라운드 로빈 스케쥴링이 조합된 경우

![image](https://user-images.githubusercontent.com/49670068/118979933-f1af1580-b9b3-11eb-9c95-6f89e6fb1150.png)

## 인터럽트란 ?

- 입출력 하드웨어 장치 이벤트 또는 예외상황 발생시 CPU에 알려 처리하는 기술이다.

## 인터럽트가 필요한 이유

1. 프로세스 실행 중, 시분할 시스템에 의해 스케쥴러가 실행 중인 프로세스를 다른 프로세스로 교체시켜야할때 (컴퓨터에 내장된 타이머 칩이 일정시간마다 인터럽트를 보냄)

2. 예를들어 파일 읽기완료시 IO 장치에서 인터럽트를 보내, 스케쥴러가 해당 파일읽기를 요청한 프로세스를 BLOCK에서 READY상태로 바꾸도록 해야함.

3. 예외상황(예를 들어 0으로 나누는 불가능한 연산) 발생시, 인터럽트를 일으켜 프로세스를 종료시켜야함.

> 인터럽트는 프로그램 내부 또는 하드웨어에서 발생시키는 이벤트이다.

## 인터럽트 종류

- 내부 인터럽트(소프트웨어 인터럽트)
    - 프로그램 내부에서 잘못된 명령, 데이터 사용시 발생
        - 0으로 나눌때
        - 사용자 모드에서 허용되지 않는 명령, 주소 접근시
        - 계산결과가 오버플로우,언더플로우 날때

- 외부 인터럽트(하드웨어 인터럽트)
    - 주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)
        - 전원이상
        - 기계문제
        - 키보드입력과 같은 IO 관련이벤트
        - 타이머 이벤트

## 시스템 콜 인터럽트

- 시스템 콜도 소프트웨어 인터럽트이다.
- 시스템 콜 실행시 어셈블리어를 보게되면, 인터럽트 OP코드가 사용된다.

```assembly
//시스템 콜을 실행시키는 어셈블리어 샘플이다.
mov eax, 1 //eax에는 시스템 콜 번호(어떤 시스템콜인지)를 넣는다.
mov ebx, 0 //ebx에는 인자를 넣는다.
int 0x80 //0x80은 인터럽트 중 시스템 콜을 의미
```

## 인터럽트와 시스템 콜

1. 시스템 콜 실행시(int 0x80) CPU를 커널 모드로 바꿔준다.
2. IDT(인터럽트 디스크립터 테이블 : 인터럽트 번호에 해당하는 실행코드 주소가 저장됨)에서 0x80에 해당하는 주소를 찾아서 실행한다.
3. eax로 부터 어떤 시스템콜을 할 것인지, ebx로 부터 인자가 무엇인지를 통해 해당 시스템 콜을 실행한다.
4. 시스템 콜 함수가 실행 완료되면 사용자모드로 변경되어 다음 줄 명령이 실행된다.

## 인터럽트와 사용자모드,커널모드

![image](https://user-images.githubusercontent.com/49670068/118983078-05a84680-b9b7-11eb-80c7-01dab6c3f2eb.png)

- 프로세스 동작시 실제로 인터럽트로 인해 유저모드와 커널모드를 넘나들며 실행된다.


## 인터럽트와 프로세스

![image](https://user-images.githubusercontent.com/49670068/118983279-39836c00-b9b7-11eb-98ae-7f359e3dab81.png)

- 프로세스 실행 중 인터럽트가 발생하면,
- 프로세스를 중단하고, 커널모드에서 인터럽트 처리 함수를 실행한다.
- 인터럽트 처리함수가 완료되면, 프로세스 A 실행을 재개한다.

## 인터럽트와 선점 스케쥴러

- 타이머 칩은 수시로 타이머 인터럽트를 발생시킨다.
- 운영체제가 타이머 인터럽트 발생횟수를 기억해 특정 횟수만큼 발생하면, 현재실행중인 프로세스를 중지하고, 다른 프로세스로 교체한다.(선점 스케쥴링)

```
...
while(true){
    if(count++==5){
        Scheduler();
        count = 0;
    }
}
..
```